import order.filter.basic topology.separation tactic

variables {Î± : Type*}

noncomputable theory

open set classical
local attribute [instance] classical.prop_decidable

/-
structure filter (Î± : Type*) :=
(sets                   : set (set Î±))
(univ_sets              : set.univ âˆˆ sets)
(sets_of_superset {x y} : x âˆˆ sets â†’ x âŠ† y â†’ y âˆˆ sets)
(inter_sets {x y}       : x âˆˆ sets â†’ y âˆˆ sets â†’ x âˆ© y âˆˆ sets)

-- A filter on `Î±` is a set of sets of `Î±` containing `Î±` itself, closed under 
-- supersets and intersection.

-- NB. This definition of filters does not require `âˆ… âˆ‰ sets`. This is done so 
-- we can create a lattice structure. `âˆ… âˆ‰ sets` should be included as a 
-- seperate proposition in lemmas.
-/

-- I'm going to follow 
-- https://web.archive.org/web/20071009170540/http://www.efnet-math.org/~david/mathematics/filters.pdf

-- First, we will find a way to generate filters for any given set of sets of Î±
-- To achieve this, we consider that the intersection of a collection of filters 
-- is also a filter, so therefore, a filter can be generated form a set of sets 
-- by taking the intersection of all filters containing this set, i.e. if `S` is 
-- type `set (set Î±)`, then the filter generated by `S` is 
-- â‹‚â‚€ { F : filter Î± | S âŠ† F.sets }

namespace filter

instance : has_coe (filter Î±) (set (set Î±)) := âŸ¨Î» F, F.setsâŸ©

/- /-- The intersection of two filters is a filter-/
instance : has_inter (filter Î±) := âŸ¨Î» F G, 
  { sets := (F : set (set Î±)) âˆ© (G : set (set Î±)),
    univ_sets := âŸ¨F.univ_sets, G.univ_setsâŸ©,
    sets_of_superset := Î» _ _ âŸ¨hxF, hxGâŸ© hsub,
      âŸ¨F.sets_of_superset hxF hsub, G.sets_of_superset hxG hsubâŸ©,
    inter_sets := Î» x y âŸ¨hxF, hxGâŸ© âŸ¨hyF, hyGâŸ©,
      âŸ¨F.inter_sets hxF hyF, G.inter_sets hxG hyGâŸ© }âŸ© -/

/-- The intersection of a collection of filters is a filter -/
instance : has_Inf (filter Î±) := { Inf := Î» ğ’,
  { sets := â‹‚ (F âˆˆ ğ’), (F : set (set Î±)), 
    univ_sets := mem_bInter $ Î» F hF, F.univ_sets,
    sets_of_superset := Î» _ _ hx hsub, mem_bInter $ Î» F hF, 
      F.sets_of_superset (mem_bInter_iff.1 hx F hF) hsub,
    inter_sets := Î» x y hx hy, mem_bInter $ Î» F hF, 
      F.inter_sets (mem_bInter_iff.1 hx F hF) (mem_bInter_iff.1 hy F hF) }}

-- With that we can now define the filter generated by an arbitary set of sets 

/-- The filter generated from `S`, a set of sets of `Î±` is the Inf of all filters 
  containing `S` -/
def generated_from (S : set (set Î±)) : filter Î± := 
  Inf { F : filter Î± | S âŠ† F.sets }

variables {S : set (set Î±)}

lemma le_generated_from : S âŠ† generated_from S := 
  Î» s hs, mem_bInter (Î» F hF, hF hs)

-- Straightaway, we see that if `âˆ… âˆˆ S`, then `filter_generated_from S` is the 
-- powerset of `Î±` 

lemma generated_of_empty (hS : âˆ… âˆˆ S) (s : set Î±) : s âˆˆ generated_from S :=
  (generated_from S).sets_of_superset (le_generated_from hS) (empty_subset s)

/-- Let `F` be a `ne_bot` filter on `Î±`, `F` is an ultra filter if for all 
  `S : set Î±`, `S âˆˆ F` or `Sá¶œ âˆˆ F` -/
@[class] structure ultra (F : filter Î±) :=
(ne_bot : ne_bot F)
(mem_or_compl_mem {S : set Î±} : S âˆˆ F âˆ¨ Sá¶œ âˆˆ F)

-- The ultra filter theorem states that for all `F : filter Î±`, there exists 
-- some ultra filter `ğ•Œ`, `F âŠ† ğ•Œ`.

-- The proof of this follows from Zorn's lemma.
-- Let `F` be a filter on `Î±`, We have the filters of `Î±` that contain `F` form 
-- a poset. Let `ğ’` be a chain (a totaly ordered set) within this set, then by 
-- Zorn's lemma, `ğ’` has at least one maximum element. Thus, by checking this 
-- maximum element is indeed an ultra filter, we have found a ultra filter 
-- containing `F`.

-- #check exists_maximal_of_chains_bounded

-- theorem exists_ultra_ge (F : filter Î±) [ne_bot F] : 
--   âˆƒ (G : filter Î±) [H : ultra G], F â‰¤ G := sorry

-- Let X be a Hausdorff space
variables {X : Type*} [topological_space X]

/-- A filter `F` on a Hausdorff space `X` has at most one limit -/
theorem tendsto_unique {x y : X} {F : filter X} [H : ne_bot F] [t2_space X]
  (hFx : tendsto id F (nhds x)) 
  (hFy : tendsto id F (nhds y)) : x = y :=
begin
  by_contra hneq,
  rcases t2_space.t2 _ _ hneq with âŸ¨U, V, hU, hV, hxU, hyV, hdisjâŸ©,
  apply H, rw [â†empty_in_sets_eq_bot, â†hdisj],
  refine F.inter_sets _ _,
    { rw â†@preimage_id _ U,
      exact tendsto_def.1 hFx U (mem_nhds_sets hU hxU) },
    { rw â†@preimage_id _ V,
      exact tendsto_def.1 hFy V (mem_nhds_sets hV hyV) }
end

variables {Y : Type*} [topological_space Y]

@[reducible] def filter_image (f : X â†’ Y) (F : filter X) : filter Y := 
  generate $ (Î» s : set X, f '' s) '' F

-- We'll use mathlib's `generate` and `map` which are the same 
-- as the ones we've defined but there is more APIs to work with

/-- The neighbourhood filter of `x` converges to `x` -/
lemma nhds_tendsto (x : X) : tendsto id (nhds x) (nhds x) := 
Î» U hU, by rwa map_id

lemma mem_filter_image_iff {f : X â†’ Y} {F : filter X} (V) : 
  V âˆˆ map f F â†” âˆƒ U âˆˆ F, f '' U âŠ† V :=
begin
  refine âŸ¨Î» h, âŸ¨_, h, image_preimage_subset _ _âŸ©, Î» h, _âŸ©,
    rcases h with âŸ¨U, hUâ‚€, hUâ‚âŸ©,
    rw mem_map,
    apply F.sets_of_superset hUâ‚€,
    intros u hu,
    rw mem_set_of_eq,
    apply hUâ‚, rw mem_image,
    exact âŸ¨u, hu, rflâŸ©    
end

lemma nhds_subset_filter_of_tendsto {x : X} {F : filter X} 
  (hF : tendsto id F (nhds x)) : (nhds x : set (set X)) âŠ† F :=
begin
  intros s hs,
  have := tendsto_def.1 hF _ hs,
  rwa preimage_id at this
end

/-- A map between topological spaces `f : X â†’ Y` is continuous at some `x : X` 
  if for all `F : filter X` that tends to `x`, `map F` tends to `f(x)` -/
theorem continuous_of_filter_tendsto {x : X} (f : X â†’ Y)
  (hF : âˆ€ F : filter X, tendsto id F (nhds x) â†’ 
    tendsto id (map f F) (nhds (f x))) : continuous_at f x :=
Î» _ hU, tendsto_def.1 (hF _ $ nhds_tendsto x) _ hU

/-- If `f : X â†’ Y` is a continuous map between topological spaces, then for all 
  `F : filter X` that tends to `x`, `map F` tends to `f(x)` -/
theorem filter_tendsto_of_continuous {x : X} {F : filter X} (f : X â†’ Y) 
  (hf : continuous_at f x) (hF : tendsto id F (nhds x)) : 
  tendsto id (map f F) (nhds (f x)) := 
begin
  rw tendsto_def at *, intros U hU,
  refine nhds_subset_filter_of_tendsto hF (hf hU),
end

end filter